# 최범균 객체지향 입문

* 비용?

  * 코드분석시간증가
  * 코드변경시간증가

* 소프트웨어의 가치 -> 변화이다.

  * keep being useful in a changing world
  * 변화에 적절하게 적응할 수 있는 것이 주요한 가치 중 하나이다.

  ### 비용과 변화

  * 낮은 비용으로 변화할 수 있어야함.
  * 이를 위한 패러다임
    * 객체지향, 함수형, 리액티브 등..
    * 코드, 설계, 아키택처
      * DDD, TDD, SOLID, 클린아키텍쳐, MSA 등..
    * 업무 프로세스/문화
      * 애자일, 데브옵스 등..

  ### 객체지향과 비용

  * 객체지향 : 캡슐화 + 다형성(추상화)를 통해 비용을 낮출 수 있다.

---



## 객체

* 절차지향 VS 객체지향

  * 절차지향 : 여러 프로시저가 데이터를 공유한다.

    * 데이터를 공유하는 방식은 수정이 어렵게 만든다.

  * 객체지향 : 객체(데이터 + 프로시저)

    * 특정 객체가 갖고있는 데이터는 해당 객체의 프로시저만 접근하게끔 설계한다.
    * 타 객체가 본인 객체의 데이터에 접근할 수는 없다.
    * 객체는 다른 객체의 프로시저를 호출(이용)하는 방식으로 연결된다.

  * ##### 객체의 핵심 -> 기능 제공

    * 객체는 제공하는 기능으로 정의되지 내부 데이터(필드)로 정의되지 않는다.
    * Ex) 회원객체
      * 암호 변경하기 기능, 차단 여부 확인하기 기능으로 정의할 수 있음
      * 소리 제어기 객체
        * 소리 크기 증가하기, 소리 크기 감소하기 기능으로 정의할 수 있음.

  * 기능명세

    * 객체란 기능을 제공하는 것이라면, 메서드(오퍼레이션)을 통해 기능을 명세한다.
    * 이름, 파라미터, 결과로 구성된다.

  * 객체와 객체

    * 객체와 객체는 기능을 사용해서 연결

    * 기능 사용이란 -> 메서드를 호출하는 것

      ```java
      VOlumeController volCont = new VOlumnCOntroller();
      volCont.increse(4); // 기능 사용.
      ```

  * 메시지

    * 객체와 객체 상호작용 -> '메시지'를 주고 받는다고 표현
    * 메서드를 호출하는 것, 리턴하는 것(결과값), 익셉셥 -> 모두 '메시지'

* 하단의 코드를 객체라고 할 수 있을까?

  ```java
  publc class Member{
  private String name;
  private String age;
  
  // 이하는 getter, setter Method가 있다고 가정
  }
  ```

  name, age에 직접 접근하는 것과 큰 차이가 없다. 

  사실상 기능이 없는셈.

  따라서 이런 류의 클래스는 데이터에 더 가깝다. (Data Class / 구조체 등..으로 표현 가능)



---



## 캡슐화

* 캡슐화

  * 데이터 + 관련 기능을 묶는 것
  * 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
    * 구현에 사용된 데이터의 상세 내용을 외부에 감춤
  * 정보은닉은 캡슐화에 포함된다.
  * 캡슐화를 왜 하느냐? 4
    * 외부에 영향 없이 객체 내부 구현 변경 가능하기 떄문

* 캡슐화를 하지 않은 예

  

  ![image-20240603093648355](/Users/daewon/Study/docs/OOP/Lecture/최범균객체지향입문/객체.assets/image-20240603093648355.png)

  상기의 코드의 문제는 변경사항이 해당 코드의 부분에만 제한적인 것이 아니라 다른 곳까지 수정을 해줘야할 여지가 많다는 것이다. 

  즉, 이곳 저곳 코드를 뒤져가며 수정해줘야할 것이다.

   ![image-20240603094547261](/Users/daewon/Study/docs/OOP/Lecture/최범균객체지향입문/객체.assets/image-20240603094547261.png)

 	반면에 아래와 같이 캡슐화를 한다면? 

![image-20240603094646448](/Users/daewon/Study/docs/OOP/Lecture/최범균객체지향입문/객체.assets/image-20240603094646448.png)

 위와 같은 상태에서 기능 요구사항이 변경된다고 해도, hasRegularPermession 메서드 내부 구현만 바뀌게 된다. 

![image-20240603094816741](/Users/daewon/Study/docs/OOP/Lecture/최범균객체지향입문/객체.assets/image-20240603094816741.png)

캡슐화를 잘하면, 요구사항의 변화에 대해서 연쇄적인 변경 전파를 최소화 할 수 있다.

* 캡슐화와 기능

  * 캡슐화 시도 -> 기능에 대한(의도) 이해를 높인다.

    ```java
    if(acc.getMembership == Regular){}
    ```

    왜 멤버십에 Regular와 같은지 검사하지?

  * 검사하는 이유 -> 계정이 Regular권한을 가졌는지 확인하기 위함

  * -> 메서드로 뺄 수 있겠다!(캡슐화 가능하겠다.)

### 캡슐화를 위한 규칙

1. Tell, Don't ASK

   - Data를 달라하지 말고 해달라고 하기

     ```java
     if(acc.getMemberShip == REGULAR){ // 특정 기능}
     // 상기의 코드를 아래와 같이 바꾸는 것이 더 적절
     
     if(acc.hasRegularPermission()){
     
     }
     ```

     - Data를 가져오지 말고, Data를 가지고 있는 대상에게 해달라고 요청하는 것이 더 적절하다.

2. Demeter's Law

   - 메서드에서 생성한 객체의 메서드만 호출

   - 파라미터로 받은 객체의 메서드만 호출

   - 필드로 참조하는 객체의 메서드만 호출

     ```java
     acc.getExpDate.isAfter(now) -> acc.isExpired();
     
     Date date = acc.getExpDate();
     date.isAfter(now);
     
     -> acc.isValid(now);
     ```

     - ->(화살표) 이후와 같이 더 표현하는 것이 더 적절하다.

### 정리

* 캡슐화 -> 기능의 구현을 외부에 감춤
* 캡슐화를 통해 기능을 사용하는 코드에 영향을 주지 않고(혹은 최소화) 내부 구현을 변경할 수 있는 유연성을 제공한다.

---



## 캡슐화 예제





