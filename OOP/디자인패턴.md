# 디자인패턴



### 전략패턴

- PurchaseService라는 클래스가 있다고 할때, 아래와 같이 구현할 수 있다.

```java
public class PurchasService{
	public String purchase(String paymentMethod){
		return "카드";
	}
}
```

- 결제 방법이 '현금'이 추가된다고 하자.
- 다음과 같이 구현할 수 있다.

```java
public class PurchaseService{
	public String purchase(String paymentMethod){
	
	String result = "";
		switch(paymentMethod){
			case: "카드"
				result = "카드로 결제"
				break;
      case: "현금"
      	result =  "현금으로 결제";
      	break;
      default :
      	result = "결제실패";
      	break;
		}
		return result;
	}
}
```

- 그런데 만약 계속해서 결제방법이 추가된다면? 
  - PurchaseService의 코드 수정은 계속해서 불가피하다.
  - 코드를 수정하지 않고 확장성 있게 작성하는 방법은 없을까?
  - => 이때 사용되는 디자인패턴이 OCP(개방폐쇄 원칙)이다.

- PurchaseService 메서드 내부에서 사용되는 분기처리를 클래스로 작성한다.ㄹ

```java
public class CardPay{

	public String pay(){
		return "카드로 결제";
	}
}

public class CashPay{
	public String pay(){
		return "현금으로 결제"
	}
}

public class TossPaymentPSay{
	public String pay(){
		return "토스페이먼츠로 결제";
	}
}

public class PurchaseService{
	pubic String purchase(String paymentMethod){
		String result = "";
		
		switch(paymentMethod){
			case : "카드"
				CardPay card = new CardPay();
				result = card.pay();
				break;
      case : "현금"
      	CashPay cash = new CashPay();
      	result = cash.pay();
      	break;
      case : "토스"
      	TossPaymnetsPay toss = new TossPaymentsPay();
      	result = toss.pay();
      	return result;
      default: 
      	break;
			
		}
	
	}

}
```

- 위와 같이 작성할 수 있다.

  - 그러나, 위에서 언급했던 것처럼 계속해서 결제방식이 확장될때마다, PurchaseService의 변경은 계속해서 발생한다.

  



 	public class PurchaseService{


 		

 	}



### 프록시패턴