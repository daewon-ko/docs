# 값타입

## 기본값 타입

### JPA의 데이터 타입 분류

1. Entity

   - Entity로 정의되는 객체
   - 데이터가 변해도 식별자로 지속해서 추적가능
   - ex)회원 Entity의 키나 나이값을 변경해도 식별자로 인식가능

2. 값타입

   - int, Integer, String과 같이 단순한 값으로 사용하는 자바 기본 타입이나 객체

   - 식별자가 없고 값만 있으므로 변경시 추적 불가

   - 값 타입 분류

   - 1. 기본 값 타입
        - 자바 기본 타입(int, double)
        - 래퍼 클래스(Integer, Long.. )
        - String
        - 생명주기를 Entity에 의존
        - 값 타입은 공유하면 안됨
          - ex) 회원 이름 변경 시 다른 회원의 이름도 함께 변경되면 안됨
     2. 임베디드 타입

     3. 컬렉션 값 타입



---



### 임베디드 타입

* 새로운 값 타입을 직접 정의가능

* JPA는 임베디드 타입이라고 함

* 임베디드 타입 역시 int, String과 같은 값 타입이다.

* 장점

  * 재사용 가능
  * 응집도가 높음
  * Period.isWork()처럼 해당 값 타입만 사용하는 의미있는 메소드 사용가능
  * 임베디드 타입을 포함한 모든 값타입은, 값 타입을 소유한 엔티티의 생명주기에 의존

* 임베디드 타입은 엔티티의 값일 뿐임

* 임베디드 타입을 사용하기 전후 매핑테이블은 동일

* ##### 객체와 테이블을 세밀하게 매핑하는게 가능

* @AttributeOverride : 속성 재정의

  * 한 엔티티에서 같은 값 타입을 사용할때 사용
  * @AttributeOverrides, @AttributeOverride 등을 사용

* 임베디드 타입이 Null이면 필드값 또한 모두 null로 들어감



---



### 값타입과 불변객체

* 값타입 공유 참조

  * 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험

  * ##### 부작용 발생 가능

* 값 타입 복사

  * 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험
  * 대신 값(인스턴스)를 복사해서 허용

* 객체 타입의 한계

  * 항상 값을 복사해서 사용하면 공유참조로 인해 발생하는 부작용을 피할 수 없음

  * 임베디드타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아닌 객체 타입

  * 자바 기본타입은 값을 대입하면 값을 복사하지만, 객체타입의 경우 참조 값을 직접 대입하면 주소값을 복사하므로 공유참조를 피할 수 없다. 

  * ```java
    //기본 타입
    
    int a = 10;
    int b  =a; // 기본타입은 값을 복사
    b = 4; //b만 변경
    
    //객체 타입
    Address a = new Address("Old");
    Address b = a; // 객체 타입은 참조값을 전달
    b.setCity("New"); // a,b 모두 변경
    ```

* 불변객체

  * 객체 타입을 수정할 수 없게끔 만들면 부작용을 원천차단 가능
  * 값 타입은 불변객체로 설계해야함.
  * 불변 객체 -> 생성 시점이후 절대 값을 변경할 수 없는 객체
  * 생성자로만 값을 설정하고, 수정자(Setter)를 만들지 않는다.
  * CF) Integer, String등은 자바가 제공하는 대표적 불변객체

---

### 값 타입의 비교

* 값타입 
  * 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 함	
* 값 타입의 비교
  * 동일성 비교 
    * 인스턴스의 참조값을 비교, == 사용
  * 동등성 비교
    * 인스턴스의 값을 비교, equals() 사용
  * 값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야함.
  * 값 타입의 equals()메소드를 적절하게 재정의

---

### 값 타입 컬렉션

* 값 타입을 하나 이상 저장할 때 사용
* @ElementCollection, @CollectionTable을 사용
* DB는 컬렉션을 같은 테이블에 저장할 수 없음.
* 컬렉션을 저장하기 위한 별도의 테이블이 필요
* 값 타입 컬렉션의 제약사항
  * 값 타입은 엔티티와 다르게 식별자 개념이 없음
  * 값은 변경하면 추적이 어려움
  * 값 타입 컬렉션에 변경사항이 생기면 주인 엔티티와 연관된 모든 데이터가 삭제되고, 값 타입 컬렉션에 있는 현재 값을 다시 저장
* 값 타입 컬렉션 대안
  * 실무에서는 상황에 따라 값 타입 컬렉션 대신 일대다 관계를 고려
  * 일대다 관계를 위한 엔티티를 만들고 여기에서 값 타입을 사용
  * 영속성 전이(Cascade) + 고아객체 제거를 사용해서 값 타입 컬렉션처럼 사용














