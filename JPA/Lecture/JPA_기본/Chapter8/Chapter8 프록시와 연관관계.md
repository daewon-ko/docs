# 프록시와 연관관계

### 프록시 기초

* em.find() VS em.getReference();
* em.find() : 실제 DB를 통해서 실제 Entity 객체를 조회
* em.getReference() : DB 조회를 미루는 가짜(프록시) 엔티티 객체 조회
  * DB에 쿼리가 나가지 않았는데 조회가 되는 것

### 프록시 특징

* 실제 클래스를 상속받아서 만들어짐
  * 하이버네이트가 내부적으로 상속한다.
* 실제 클래스와 겉모양이 같음
* 사용하는 입장에서는 진짜 객체인지, 프록시 객체인지 구분하지 않고 사용한다.
  * 상속해도 부모타입으로 사용할 수 있기때문(다형성 활용)



<img width="846" alt="image" src="https://github.com/daewon-ko/docs/assets/105340285/ea938025-38ac-4df4-9923-949b8ee97e00">

getReference()하는 순간엔 target 객체가 껍데기이다. 

* 프록시 객체는 실제 객체의 참조(target)을 보관
* 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출
  * ex) 프록시 객체의 getName()을 호출하면 프록시객체가 실제 객체의 getName() 메서드를 호출한다.

<img width="1136" alt="image-20240627135122117" src="https://github.com/daewon-ko/docs/assets/105340285/be24d0e8-00d8-4827-8fe5-be0c4490a488">

프록시 매커니즘(하이버네이트가 구현한 매커니즘)

>  프록시 객체의 메서드를 호출한다. -> 원본 객체가 null이므로 영속성 컨텍스트에 진짜 객체를 요청한다. -> 영속성 컨텍스트가 DB를 조회한 후 실제 객체를 반환한다. -> 영속성 컨텍스트가 target에 실제 객체를 연결해준다. -> 따라서 프록시에서 getName()과 같은 메서드를 호출하면 실제 객체의 getName()이 반환된다.

* 프록시 객체는 처음 사용할때 한 번만 초기화

  * Q) 프록시 객체가 초기화 된 이후  원본객체에 변화가 생기면, 객체간 정합성의 문제가 생기지 않나?
    * <- 트랜잭션 범위 내에서 영속성 컨텍스트가 관리된다. 따라서 한 트랜잭션 범위 내에서는 해당사항이 없다. 

* 프록시 객체를 초기화 할때, 프록시 객체가 실제 엔티티로 바뀌는 것이 아님. 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능

* 프록시 객체는 원본 엔티티를 상속받음. 따라서 타입 체크시 유의

  * ##### == 비교가 아닌, instance Of를 사용해야함

* 영속성 컨텍스트에 찾는 Entity가 이미 있으면, em.getReference()를 호출해도 실제 엔티티 반환

* 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생



---

### 즉시로딩과 지연로딩

* 프록시와 즉시로딩 주의

  * 가급적 지연로딩만 사용

  * 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생

  * 즉시로딩은 JPQL에서 N+1 문제가 발생

  * @ManyToOne, @OneToOne은 기본값이 즉시로딩

    * ##### -> 반드시 LAZY로 설정해줘야함

  * @OneToMany, @ManyToMany는 기본이 지연로딩



---

### 영속성 전이

* 특정 엔티티를 영속상태로 만들 때, 연관된 엔티티도 함께 영속상태로 만들고 싶을 때
* 영속성 전이는 연관관계 매핑과 아무 연관이 없음
* 엔티티를 영속화할때, 연관 엔티티도 함께 영속화하는 편리함을 제공하는 것일뿐
* 종류
  * ALL
    * 모든 라이프사이클을 맞출떄
  * PERSIST
    * 저장할때만 맞출때
  * REMOVE
* 소유자가 하나일때는 사용해도 되지만, 해당 Entity(자식 Entity)가 다른 Entity와 연관관계가 있을때는 쓰면 안됨.
* 즉 단일 Entity에 대하여 종속적일때는 사용해도 무방하다. 

### 고아객체

* 부모 엔티티와 연관관계가 사라진 엔티티를 자동으로 삭제
* orphanRemoval= true
* 영속성 전이와 마찬가지로 참조하는 곳이 하나일때만 사용해야함!
* @OneToOne, @OneTOMany만 가능
* 개념적으로 부모를 제거하면, 자식은 고아가 됨. 고아객체 기능을 활성화하면 CascadeType.REMOVE처럼 동작

* CascadeType.ALL + orphanRemoval = true
  * 스스로 생명주기를 관리하는 Entity는 em.persist()로 영속화하고 em.remove()로 제거
  * 두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식의 생명주기를 관리가능

