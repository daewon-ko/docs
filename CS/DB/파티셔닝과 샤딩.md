# 파티셔닝 샤딩





**왜 데이터베이스를 분할하나?**

- 데이터베이스 볼륨이 커지면 데이터베이스 읽기 /쓰기 성능이 감소한다.
  - 여기서 말하는 ‘볼륨’이란 레코드의 크기 양 따위를 말하는건가?
  - 읽기란 인덱스 조회 시에도 많이 시간이 소모될 수 있으나, 쓰기 작업에서도 데이터 볼륨이 유의미하게 차이를 주는가?



**파티셔닝**



파티셔닝은 ‘ 매우 큰 테이블을 여러 개의 테이블로 분할하는 작업’입니다. 

- 큰 데이터를 여러 테이블로 나눠 저장하기 때문에 쿼리 성능이 개선될 수 있음
- 데이터는 여러 테이블에 물리적으로 분산되어 저장되지만, 사용자는 하나의 테이블에 접근하는 것처럼 사용 가능
- MYSQL 기준 InnoDB, NDB등의 스토리지 엔진에서 사용 가능







![Image](https://github.com/user-attachments/assets/3c50818c-c403-44bd-9526-0a6ab09b3171)

*출처:* [*https://docs.oracle.com/cd/B12037_01/server.101/b10743/partconc.htm*](https://docs.oracle.com/cd/B12037_01/server.101/b10743/partconc.htm)



**파티셔닝의 종류**

간단히 4가지만 요약하면 다음과 같습니다. 



- List Partitioning
  - 데이터 값이 특정 목록에 포함되면 데이터를 분리
  - 사용처
    - 시간 개념 단위로 분석 / 삭제
    - 범위 기반으로 균등한 파티션
  - 파티션 재구성
    - 파티션의 레코드가 많을 수록 오래걸림
    - 최소 읽기 잠금 필요
  - 파티션 추가 및 삭제
    - 가장 마지막 파티션만 추가 가능하고 삭제는 매우 빠름
- Range Partitioning
  - 범위를 기준으로 데이터를 분리
  - 레인지 파티션과 대부분 흡사
    - 키 값 하나하나를 리스트로 나열해야 한다.
    - ’MAXVALUE’와 같은 값을 사용할 수는 없음
  - 사용처
    - 파티션 키 값이 카테고리처럼 고정적
    - 키 값이 연속되지 않고 정렬 순서와 관계없음
- Hash Partitioning
  - 해시함수를 이용하여 특정 컬럼의 값을 해싱하여 저장할 파티션을 선택
  - 파티션 간의 데이터가 고르게 분포되도록 하기 위해 사용
  - 파티션 표현식의 결과를 MOD 연산하여 결과가 항상 정수타입
  - 사용처
    - 특정 컬럼의 값에 사용빈도가 영향받지 않음
    - 모든 데이터들이 비슷한 사용빈도를 가져야할때
  - 파티션의 삭제, 분할, 병합
    - 파티션 갯수만 변경 가능하며 만약 해야한다면 전체 데이터를 재분배 해야함
- Composite Partitioning
  - 상기의 방식 중 2가지 이상을 결합하여 사용



[(MySQL) 파티션의 종류](https://5min.medium.com/mysql-파티션의-종류-58ddb18078f)



**파티션 Key 전략**

- 파티셔닝에서 가장 중요한 것은 Partition Key를 무엇으로 정할가 하는 것
- 파티셔닝은 한 번 하게되면, 파티션 테이블을 다시 합치거나, 파티셔닝 기준을 수정하는 것은 힘든 작업이므로 신중하게 Partition Key를 선정해야함.



**파티셔닝의 장단점**

장점

- 적은 수의 파티션을 참조해서 파티셔닝 이전보다 높은 성능을 보인다.

단점

- 테이블 풀스캔을 타게되면, 파티셔닝 이전보다 안 좋은 성능이 발생할 수도 있다.

→ 따라서 파티셔닝 시, 본인이 작성한 쿼리가 ‘얼만큼의 파티션 테이블’을 참조할 지가 기준이 되어야한다. 



————————



**Application Level에서 파티셔닝 전략을 어떻게 고려할 수 있는가?** 



전 글에서 간단하게 정리한 파티셔닝은 DB관점에서의 서술입니다. 

테이블을 쪼개고 

Application Level에서 파티셔닝과 관련하여 설정해줄 수 있는 것은 없을까? 





**Snowflake**

- 분산환경에서 고유한 ID를 생성하는 전략으로 트위터가 처음 도입한 방식
- DB가 아닌 Application에서 각 WAS에서 PK를 생성하는 전략으로서 분산환경에서 고유한 ID값을 유지하는 것이 중요하기 때문에 아래와 같은 특성을 이용하여 고유성을 유지할 수 있음.
- Snowflake Id는 64비트 숫자로 구성된 고유한 ID



![Image](https://github.com/user-attachments/assets/c29160c7-93bc-419f-b3c8-47e7f2ce6f14)

*참고 : 가상면접 대규모 시스텀 설계기초 1권 7장*

| **Bit** | **의미**                                         |
| ------- | ------------------------------------------------ |
| 1비트   | 예약 비트 (항상 0)                               |
| 41비트  | Timestamp (밀리초 단위)                          |
| 10비트  | Machine ID (서버 또는 노드 식별)                 |
| 12비트  | Sequence Number (동일한 밀리초 내에서 중복 방지) |



**그렇다면 왜 DB에서 PK를 생성하지 않을까?**



PK를 생성하는 전략으로 가장 많이 이용하는 것이 DB의 Auto-Increment의 기능을 사용하는 것입니다.(NOSQL은 사용불가능하다고 하지만)



이 방법은 그런데 과연 만능일까요? 



WAS가 Scale-Out된 분산환경에서는 DB는 병목지점이 될 수 있습니다. 



즉, 모든 트랜잭션이 ID를 받기 위해 DB에 INSERT 요청을 보내게 됩니다. 

지나친 비약일 수 있지만, 하나의 DB에 갑자기 무수히 많은 Insert작업이 들어가게 된다면 어떻게 될까요? 당연히 DB 리소스가 쓰이는 



또한 샤딩과 같은 기술을 이용하여 DB를 분산시킨 경우에 Auto-Increment를 사용하는 경우, 서로 다른 샤드에서 동일한 PK가 존재할 수 있기 때문에 N대 이상의 DB를 사용하는 경우 하나의 서비스에서 id값의 고유성을 보장하기 위해서는 Auto-Increment와 같은 방식은 문제가 존재합니다. 



위와 같은 접근에 PK를 DB에서 생성하는 전략을 이용하고 있기 때문에 발생하는 문제이기도 합니다. Application단에서 ID를 발급할 수는 없을까요?

-> **Snowflake ID**





---



**샤딩**

동일한 스키마를 가지고 있는 N대의 데이터베이스 서버들에 데이터를 작은 단위로 나누어 분산저장하는 기법이고, 나누어 저장하는 단위를 ‘샤드’라고 합니다. 



파티셔닝은 모든 데이터를 하나의 데이터베이스 내에서 분할하여 저장하지만, 샤딩은 서로 다른 데이터베이스의 서버에 동일한 스키마를 가진 데이터를 분산하여 저장합니다. 물리적으로 서로 다른 데이터 베이스 서버에 저장하므로 쿼리성능향상 효과 및 부하 분산이 가능합니다. 이를 통해 데이터베이스 차원의 스케일 아웃이 가능하며, 쓰기작업이나, 데이터의 수평확장이 요구되는 대규모 시스템에서 효율적으로 사용된다. 



샤딩은 애플리케이션 레벨에서 구현하는 것이 일반적이긴 하나, 애플리케이션 서버에서 동작하는 형태, 미들티어에서 동작하는 방식, DB에서 샤딩을 제공하는 방식 등으로 나눠집니다. 



**샤딩의 종류**



- Hash Sharding
  - DB 클러스트 중 PK값인 모듈러 연산 결과를 통해 샤드를 결정
  - 총 데이터 베이스 수가 결정해져있을때 유용
  - 데이터베이스 개수가 줄어들거나 늘어나면 해쉬함수도 변화가 필요하며 데이터 재정렬이 필요
- Range Sharding
  - PK값의 범위에 따라서 샤드를 분배
  - Hash Sharding과 비교하여 데이터베이스를 늘리는데 비용이 크게 들지 않는다.
  - 그러나, 특정 Ragnge의 Shard에만 트래픽이 몰리는 경우가 있을 수 있음
    - 예를 들면, 최신 게시글에만 트래픽이 몰리는 것과 같은 경우
    - 이럴 경우, Re-Sharding하고 트래픽이 저조한 Database는 통합이 필요