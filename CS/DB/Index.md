# 인덱스 구조에 대해서







### 인덱스

- 책의 색인과 비슷
- ’추가적인 쓰기작업과 저장공간을 활용하여 데이터베이스 테이블의 검색속도를 향상시키기 위한 자료구조’
- 조회 속도 향상에 큰 기여를 할 수 있음.

### 인덱스 장단점

하단은 인덱스의 장단점입니다. 



- 장점
  - 조회 속도 향상 가능
  - 시스템 부하 줄일 수 있음.
- 단점
  - 인덱스 관리 위해 DB의 10%에 해당하는 저장공간이 필요
  - 인덱스 관리 위해 추가 작업 필요
  - 잘못 사용하면 성능에 악영향을 줄 수 있음.



=> CREATE, UPDATE, DELETE가 빈번한 속성(컬럼)에 인덱스를 걸면, 인덱스의 크기가 지나치게 커져서 성능에 악영향을 줄 수 있음. 



UPDATE, DELETE는 내부 저장공간에서, 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’처리로 그대로 둔다. 



### 인덱스의 자료구조



**기본 전제**

모든 인덱스든 인덱스 조회 자체가 디스크 I/O에 카운트 되는 작업이다. 

인덱스도 결국 디스크 안에 저장된 별도의 자료구조이다. 

즉, 인덱스를 조회한다는 것은 디스크에 있는 인덱스 파일(B+tree)를 읽는 것이고, 해당 메모리(인덱스) 안에 없으면, 디스크에서 읽어야 하는 것



**클러스터형 인덱스(Primary Key Type)**



MYSQL 기준으로 InnoDb엔진에서는 PK에 대해 자동으로 클러스터형 인덱스를 만듭니다.

클러스터형 인덱스 

- 인덱스와 실제 데이터가 같은 구조 안에 클러스터링되어있다는 뜻

InnoDB는 PK값을 기준으로 B+Tree구조의 인덱스를 만들고, 그 리프 노드에 실제 데이터를 같이 저장한다.



- 기본키 기반으로 데이터를 저장한 인덱스 구조를 ‘클러스터형 인덱스’라고 함.
- 특정 데이터를 찾을 때, PK기반이면 클러스터형 인덱스 1번 조회만으로 바로 찾을 수 있고, 보조인덱스를 통해 데이터를 찾으면, 보조인덱스 → 클러스터형 인덱스를 2차 접근하므로 데이터셋을 가져온다.







### 보조 인덱스(Secondary Index)(= 논 클러스터 인덱스)





![Image](https://github.com/user-attachments/assets/7bc6d1c8-a2b4-4e27-9c5d-b01110259870)



PK값 이외의 컬럼에 거는 모든 인덱스는 사실상 보조인덱스이다.

보조인덱스(세컨더리인덱스)는 테이블의 물리적인 순서는 건드리지 않고, 테이블에서 특정 값의 주소 값을 참조한다.

보조인덱스 역시 클러스터형 인덱스와 마찬가지로 B+Tree 구조이고 log2^n의 시간복잡도를 가지고 있다.

보조인덱스의 리프노드에는 해당 컬럼의 값과 해당 Row의 PK값이 존재한다.

따라서 보조인덱스를 사용할경우, 검색 시에 인덱스 → 클러스터 인덱스를 접근해서 **총 2번 조회를 통해 데이터셋을 조회하게 된다**. 



- 세컨더리 인덱스는 B+Tree구조이므로 인덱스 컬럼 기준으로 ‘논리적 정렬’이 되어있음.
- 그러나, 실제 데이터는 ‘**물리적 정렬이 되어있지 않음’**
  - 따라서, 세컨더리 인덱스 리프노드에 데이터와 PK를 통해 다시 Row를 찾아야한다.
  - 해당 데이터 자체가 순차적으로 정렬되어있지 보장되어있지 않으므로







하단은 보조 인덱스의 장단점이다. 



장점:

- 기본키 순서로 정렬된 상태라 **범위 조회**나 **정렬 쿼리**에 강함.

- 물리적으로 정렬이 필요하지 않기 때문에, n개의 non-clustered index를 가질 수 있음

- 보조 인덱스가 접근할 때도 **기본키를 통해 빠르게 원본 데이터 조회 가능**.



⠀단점:

- 기본키가 커질수록 보조 인덱스의 공간도 커짐 (보조 인덱스에 PK를 포함하니까)
- 기본키를 **자주 바꾸면 물리적 재정렬이 필요**해서 비용이 큼
  - 테이블에서 데이터 수정 시, 각 Index를 업데이트해야하므로 속도가 느릴 수 있음.





**보조 인덱스는 언제 사용해야할까?**

- Read가 많은 상황에서 적절히 사용한다.
- 그러나 상단에 언급했듯, 쓰기작업 발생시 해당 데이터를 포함하는 모든 Index를 업데이트해야하므로 느리다.





**복합 인덱스(Composite Index)**



![Image](https://github.com/user-attachments/assets/affdb6b0-fb8a-409a-933e-8718574af518)



- 2개 이상의 컬럼으로 Index를 설정하면 Composite Index라고 부름
- 예를 들어 ‘name’, ‘country’가 엮인 쿼리가 많이 실행되면, 각각 name, country라는 필드에 대해서 인덱스를 만들어주기보다는 두 개 컬럼을 묶은 Composite Index를 만들어주는게 좋다.



복합인덱스에서 **중요한 것은 컬럼 순서**이다.



예를들어, name, country를 묶어서 복합인덱스를 설정시에, Name, (Name, Country)조회시에는 해당 쿼리가 복합인덱스를 잘 이용가능하지만, ‘Country’만 포함하는 쿼리에는 비효율적이다. 



따라서 쿼리에서 데이터를 가장 잘 걸러낼 수 있는 컬럼에 우선순위를 두고 인덱스를 설정해주는 것이 중요하다. 즉, 데이터의 범위를 가장 많이 좁힐 수 있는 컬럼이 앞에 오는 것이 효율적인데, 또다른 예시를 들면 ( email, name)이라는 컬럼을 복합인덱스 설정한다고 하자. 



name은 동명이인(ex. 김철수)가 많다고 하고, email은 모두 고유하다고 하자. 

그렇다면, email을 복합인덱스의 앞의 컬럼에 설정하는것이 레코드 수를 좁혀서 성능을 끌어올리는데 큰 도움이 된다. 

또한 복합인덱스 생성 시에 많은 컬럼을 포함하게 되고 이에 따라 당연히 인덱스의 공간크기를 많이 차지하게된다. 



따라서 저장 공간과 비용사이에 균형을 찾는 것이 중요하다.



**커버링 인덱스(Covering Index)**



커버링 인덱스는 인덱스를 활용해 디스크 접근 없이 빠르게 데이터를 가져오는 기법이다. \

만약, Query에서 사용하는 컬럼들이 전부 커버링 인덱스 테이블에 있다면 굳이 Disk에서 접근할 필요 없이 Index Table에서 처리가 가능하다. 

해당 기법을 통해 Disk I/O를 줄일 수 있으나 Write 작업시 부하가 생기게 된다. 